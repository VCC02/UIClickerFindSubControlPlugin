{
    Copyright (C) 2025 VCC
    creation date: 18 Feb 2025
    initial release date: 23 Mar 2025

    author: VCC
    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:
    The above copyright notice and this permission notice shall be included
    in all copies or substantial portions of the Software.
    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
    IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
    OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
}


library UIClickerFindSubControl;

{$mode objfpc}{$H+}

uses
  Windows,
  Interfaces, Classes, SysUtils, Graphics, FindSubControlDM, ImgList,
  ClickerActionPlugins, ClickerUtils, DllUtils,
  FindSubControlPluginProperties, ClickerActionProperties,
  ctypes, CLHeaders
  ;


var
  AddToLogCallback: TOnActionPlugin_AddToLog;



procedure AddToLog(AMsg: string);  //thread safe
begin
  if @AddToLogCallback <> nil then
    AddToLogCallback(DefaultPluginReference, @AMsg[1]);
end;


function GetAPIVersion: DWord; cdecl;
begin
  Result := CActionPlugin_APIVersion;
end;


procedure GetListOfProperties(APluginReference: Pointer;                 //UIClicker passes the plugin reference to the plugin, then the plugin calls some callbacks with that reference
                              AListOfProperties: Pointer;
                              AListOfPropertiesLen: PDWord;
                              AOnActionPlugin_UpdatePropertyIcons: TOnActionPlugin_UpdatePropertyIcons); cdecl;
var
  Properties: string;
  i: Integer;
  TempMemStream: TMemoryStream;
  Bmp: TBitmap;
begin
  Properties := FillInPropertyDetails;
  AListOfPropertiesLen^ := SetPointedContentFromString(Properties, AListOfProperties);

  dmProperties := TdmProperties.Create(nil);
  try
    for i := 0 to CPropertiesCount - 1 do
    begin
      TempMemStream := TMemoryStream.Create;
      Bmp := TBitmap.Create;
      try
        Bmp.PixelFormat := pf24bit;
        Bmp.Width := dmProperties.imglstProperties.Width;
        Bmp.Height := dmProperties.imglstProperties.Height;
        Bmp.Canvas.Pen.Color := clWhite;
        Bmp.Canvas.Brush.Color := clWhite;
        Bmp.Canvas.Rectangle(0, 0, Bmp.Width, Bmp.Height);

        dmProperties.imglstProperties.Draw(Bmp.Canvas, 0, 0, i, dsNormal, itImage);
        Bmp.SaveToStream(TempMemStream);

        AOnActionPlugin_UpdatePropertyIcons(APluginReference, TempMemStream.Memory, TempMemStream.Size);
      finally
        TempMemStream.Free;
        Bmp.Free;
      end;
    end;
  finally
    dmProperties.Free;
  end;
end;


procedure DrawWipeRect(ACanvas: TCanvas; NewWidth, NewHeight: Integer);
begin
  ACanvas.Lock;
  try
    ACanvas.Brush.Style := bsSolid;
    ACanvas.Brush.Color := clWhite;
    ACanvas.Pen.Color := clWhite;
    ACanvas.Rectangle(0, 0, NewWidth {- 1}, NewHeight {- 1});
  finally
    ACanvas.Unlock
  end;
end;


procedure WipeBitmap(ABitmap: TBitmap; NewWidth, NewHeight: Integer);
begin
  //ABitmap.Clear;
  ABitmap.SetSize(NewWidth, NewHeight);
  DrawWipeRect(ABitmap.Canvas, NewWidth, NewHeight);
end;


function GetKernelSrcRGB(ARGBSizeOnBG, ARGBSizeOnSub: Byte; ASubBmpHeight: Integer): string;
var
  RGBSizeStrOnBG, RGBSizeStrOnSub: string;
  SubBmpHeightStr: string;  //used (in concatentation) if declaring arrays of SubBmpHeight length, like 'uchar TempArr[' + IntToStr(SubBmpHeight) + '];'
begin      //int is 32-bit, long is 64-bit
  if not (ARGBSizeOnBG in [3, 4]) or not (ARGBSizeOnSub in [3, 4]) then
  begin
    Result := 'Bad code';
    Exit;
  end;

  RGBSizeStrOnBG := IntToStr(ARGBSizeOnBG);
  RGBSizeStrOnSub := IntToStr(ARGBSizeOnSub);
  SubBmpHeightStr := IntToStr(ASubBmpHeight);

  Result :=
    '__kernel void MatCmp(                      ' + #13#10 +
    '  __global uchar* ABackgroundBmp,          ' + #13#10 +
    '  __global uchar* ASubBmp,                 ' + #13#10 +
    '  __global int* AResultedErrCount,         ' + #13#10 +
    '  const unsigned int ABackgroundWidth,     ' + #13#10 +
    '  const unsigned int ASubBmpWidth,         ' + #13#10 +
    '  const unsigned int ASubBmpHeight,        ' + #13#10 +    //not needed in this kernel, it is here for compatibility only (to have a similar list of parameters, to be able to directly call this kernel from host, if needed)
    '  const unsigned int AXOffset,             ' + #13#10 +
    '  const unsigned int AYOffset,             ' + #13#10 +
    '  const uchar AColorError,                 ' + #13#10 +
    '  const long ASlaveQueue)                  ' + #13#10 +    //not needed in this kernel, it is here for compatibility only ...
    '{                                          ' + #13#10 +
    '  int YIdx = get_global_id(0);             ' + #13#10 + //goes from 0 to SubBmpHeight - 1
    '  __global uchar const * BGRow = &ABackgroundBmp[((YIdx + AYOffset) * ABackgroundWidth + AXOffset) * ' + RGBSizeStrOnBG + '];' + #13#10 + //pointer to the current row, indexed by YIdx
    '  __global uchar const * SubRow = &ASubBmp[(YIdx * ASubBmpWidth) * ' + RGBSizeStrOnSub + '];' + #13#10 + //pointer to the current row, indexed by YIdx
    '  int ErrCount = 0;                             ' + #13#10 +
    '  for (int x = 0; x < ASubBmpWidth; x++)        ' + #13#10 +
    '  {                                             ' + #13#10 +
    '     int x0_BG = x * ' + RGBSizeStrOnBG + ' + 0;   ' + #13#10 +
    '     int x1_BG = x * ' + RGBSizeStrOnBG + ' + 1;   ' + #13#10 +
    '     int x2_BG = x * ' + RGBSizeStrOnBG + ' + 2;   ' + #13#10 +
    '     int x0_Sub = x * ' + RGBSizeStrOnSub + ' + 0;   ' + #13#10 +
    '     int x1_Sub = x * ' + RGBSizeStrOnSub + ' + 1;   ' + #13#10 +
    '     int x2_Sub = x * ' + RGBSizeStrOnSub + ' + 2;   ' + #13#10 +
    '     short SubPxB = SubRow[x0_Sub];             ' + #13#10 +
    '     short BGPxB = BGRow[x0_BG];                ' + #13#10 +
    '     short SubPxG = SubRow[x1_Sub];             ' + #13#10 +
    '     short BGPxG = BGRow[x1_BG];                ' + #13#10 +
    '     short SubPxR = SubRow[x2_Sub];             ' + #13#10 +
    '     short BGPxR = BGRow[x2_BG];                ' + #13#10 +
    '     if ((abs(SubPxR - BGPxR) > AColorError) || ' + #13#10 +
    '         (abs(SubPxG - BGPxG) > AColorError) || ' + #13#10 +
    '         (abs(SubPxB - BGPxB) > AColorError))   ' + #13#10 +
    '     {                                          ' + #13#10 +
    '       ErrCount++;                              ' + #13#10 +
    '     }  //if                                    ' + #13#10 +
    '  }  //for                                      ' + #13#10 +
    '  AResultedErrCount[YIdx] = ErrCount;           ' + #13#10 +    //get_work_dim() returns 3. It should be 1, to work with a single dimension only.
    '  //AResultedErrCount[YIdx] = get_work_dim();   ' + #13#10 +  //Uncomment, to get the value of get_work_dim on a slave kernel.
    '  //AResultedErrCount[YIdx] = YIdx + 200;       ' + #13#10 +  /////////////////////////////////////////////// return inst idx, for debugging  - this proves that multiple instances exist and they are indexed properly
    '}                                               ' + #13#10 +
    '                                           ' + #13#10 +
    '__kernel void SlideSearch(                 ' + #13#10 +
    '  __global uchar* ABackgroundBmp,          ' + #13#10 +
    '  __global uchar* ASubBmp,                 ' + #13#10 +
    '  __global int* AResultedErrCount,         ' + #13#10 +
    '  __global int* ADebuggingInfo,            ' + #13#10 +
    '  const unsigned int ABackgroundWidth,     ' + #13#10 +
    '  const unsigned int ASubBmpWidth,         ' + #13#10 +
    '  const unsigned int ASubBmpHeight,        ' + #13#10 +
    '  const unsigned int AXOffset,             ' + #13#10 +
    '  const unsigned int AYOffset,             ' + #13#10 +
    '  const uchar AColorError,                 ' + #13#10 +
    '  const long ASlaveQueue,                  ' + #13#10 +
    '  const unsigned int ATotalErrorCount)     ' + #13#10 +
    '{                                          ' + #13#10 +
    '  queue_t SlaveQueue = (queue_t)ASlaveQueue;' + #13#10 +      //get_default_queue() requies OpenCL >= 2.0 and __opencl_c_device_enqueue    (so... it may not be available)
    '  clk_event_t AllKernelsEvent;             ' + #13#10 +
    '  clk_event_t FinalEvent;                  ' + #13#10 + //used as a return event, from enqueue_marker
    '                                           ' + #13#10 +
    '  ndrange_t ndrange = ndrange_1D(1, ASubBmpHeight);' + #13#10 +   //defined as ndrange_1D(global, local)
    //'  ndrange_t ndrange = ndrange_1D(1);' + #13#10 +
    '  kernel_enqueue_flags_t MyFlags;          ' + #13#10 +
    '  MyFlags = CLK_ENQUEUE_FLAGS_NO_WAIT;     ' + #13#10 +
    '  int i, j, k = 0;                         ' + #13#10 +
    '  bool Found = false;                      ' + #13#10 +
    '  int EnqKrnErr = -1234;                   ' + #13#10 +
    '  int EnqMrkErr = -4567;                   ' + #13#10 +
    '  int XOffset = AXOffset;                  ' + #13#10 +
    '  int YOffset = AYOffset;                  ' + #13#10 +
    '  int DifferentCount = 0;                  ' + #13#10 +
    '  for (i = 0; i < YOffset; i++)            ' + #13#10 +
    '  {                                        ' + #13#10 +
    '    for (j = 0; j < XOffset; j++)          ' + #13#10 +
    '    {                                      ' + #13#10 +
    '      EnqKrnErr = enqueue_kernel(          ' + #13#10 +      //this may return -10 (this is an unknown value), if ndrange is ndrange_1D(ASubBmpHeight). It is also possible that there is an "out of range or index" access in a slave kernel. This happens after the first call.
    '          SlaveQueue,                      ' + #13#10 +      //using SlaveQueue, instead of get_default_queue()
    '          MyFlags,                         ' + #13#10 +
    '          ndrange,                         ' + #13#10 +
    '          0,                               ' + #13#10 +  //comment for err -10   //Although enqueue_kernel works sometimes on an OpenCL 1.2 device (and 3.0 host), there are features which are still not available.
    '          NULL,                            ' + #13#10 +  //comment for err -10
    '          &AllKernelsEvent,                ' + #13#10 +  //comment for err -10      //when returning an event, enqueue_kernel enters a bad state, causing CL_INVALID_COMMAND_QUEUE to be returned at host, at the clFinish call. Subsequent runs, result in error -9999 at clCreateContext.
    '          ^{MatCmp(ABackgroundBmp, ASubBmp, AResultedErrCount, ABackgroundWidth, ASubBmpWidth, ASubBmpHeight, i, j, AColorError, ASlaveQueue);});' + #13#10 +

    '      ADebuggingInfo[0] = EnqKrnErr;'     + #13#10 +

    '      EnqMrkErr = enqueue_marker(SlaveQueue, 1, &AllKernelsEvent, &FinalEvent);' + #13#10 + //This call seems to wait for all slave kernel instance, although AllKernelsEvent is not used by enqueue_kernel. Without this waiting, it would be a race condition.
    '      ADebuggingInfo[1] = EnqMrkErr;'     + #13#10 +
    //'      release_event(AllKernelsEvent);      ' + #13#10 +
    //'      release_event(FinalEvent);           ' + #13#10 +

    ''                                            + #13#10 +
    '      DifferentCount = 0;                  ' + #13#10 +     //collect the results from all slave kernels
    '      for (k = 0; k < ASubBmpHeight; k++)  ' + #13#10 +
    '        DifferentCount += AResultedErrCount[k];' + #13#10 +
    ''                                            + #13#10 +
    '      int TotalErrorCount = ATotalErrorCount;' + #13#10 +
    '      if ((DifferentCount < TotalErrorCount) || (EnqKrnErr < 0))' + #13#10 +
    '      {                                    ' + #13#10 +
    '        Found = true;                      ' + #13#10 +
    '        break;'                              + #13#10 +
    '      }'                                     + #13#10 +
    '    }' + #13#10 + //for j
    '    if (Found || EnqKrnErr < 0) '            + #13#10 +
    '      break;'                                + #13#10 +
    '  }' + #13#10 + //for i

    '  ADebuggingInfo[2] = i;'   + #13#10 +
    '  ADebuggingInfo[3] = j;'   + #13#10 +
    '  ADebuggingInfo[4] = DifferentCount;'   + #13#10 +
    '  ADebuggingInfo[5] = (int)Found;'       + #13#10 +
    '  ADebuggingInfo[6] = get_work_dim();'   + #13#10 +

    '  release_event(AllKernelsEvent);      ' + #13#10 +
    '  release_event(FinalEvent);           ' + #13#10 +
    '} //func                               ' + #13#10
    ;
end;


function BitmapPosMatch_BruteForceOnGPU(APlatformIndex, ADeviceIndex: Integer;
                                        ASrcBmpData, ASubBmpData: Pointer;
                                        ABytesPerPixelOnSrc, ABytesPerPixelOnSub: Integer;
                                        ASourceBitmapWidth, ASourceBitmapHeight, ASubBitmapWidth, ASubBitmapHeight: Integer;
                                        AColorErrorLevel: Integer;
                                        out SubCnvXOffset, SubCnvYOffset: Integer;
                                        var AFoundBitmaps: TCompRecArr;
                                        ATotalErrorCount, FastSearchColorErrorCount: Integer;
                                        AUseFastSearch, AIgnoreBackgroundColor, AGetAllBitmaps: Boolean;
                                        ABackgroundColor: TColor;
                                        var AIgnoredColorsArr: TColorArr;
                                        ASleepySearch: Byte;
                                        AOutsideTickCount, APrecisionTimeout: QWord;
                                        AThreadCount: Integer;
                                        out AResultedErrorCount: Integer;
                                        out ADebuggingInfo: string;
                                        AStopSearchOnDemand: PBoolean = nil;
                                        StopSearchOnMismatch: Boolean = True): Boolean;

  procedure LogCallResult(AError: Integer; AFuncName, AInfo: string; AExtraErrorInfo: string = '');
  var
    Msg: string;
  begin
    if AError = 0 then
      Exit;

    while Pos(#0, AExtraErrorInfo) > 0 do
    begin
      Delete(AExtraErrorInfo, Pos(#0, AExtraErrorInfo), 1);
      if Length(AExtraErrorInfo) = 0 then
        Break;
    end;

    if Pos(#0, AInfo) > 0 then
      Delete(AInfo, Pos(#0, AInfo), 1);

    Msg := 'Error ' + CLErrorToStr(AError) + ' " at "' + AFuncName + '" OpenCL API call.  ' + AExtraErrorInfo;
    if AInfo <> '' then
      Msg := Msg + '  Expected: ' + AInfo;

    raise Exception.Create(Msg);
  end;

var
  Error, SecondError: Integer;
  DiffCntPerRow, DbgBuffer: array of LongInt;

  KernelSrc: string;

  GlobalSize, GlobalSizeWithDeviceEnqueue: csize_t;
  LocalSize: csize_t;
  DeviceIDs: Pcl_device_id;
  Context: cl_context;
  CmdQueue, SlaveCmdQueue: cl_command_queue;
  CLProgram: cl_program;
  CLKernel: cl_kernel;

  i, j, k: Integer;
  BackgroundBmpWidth, BackgroundBmpHeight: Integer;
  SubBmpWidth, SubBmpHeight: Integer;
  XOffset, YOffset: Integer;
  ColorError: Byte;

  BackgroundBufferRef: cl_mem;
  SubBufferRef: cl_mem;
  ResBufferRef: cl_mem;
  DbgBufferRef: cl_mem;

  DevType: cl_device_type; //GPU
  PlatformIDs: Pcl_platform_id;
  PlatformCount, DeviceCount: cl_uint;
  BuildOptions: PAnsiChar;
  Info: string;
  InfoLen: csize_t;
  QueueProperties: array[0..8] of cl_command_queue_properties;
  OpenCLDll: TOpenCL;
begin
  //ToDo: - Implement FastSearch property, which verifies a small rectangle (Top-Left), before going full bmp.
  //ToDo: - Implement ignored colors, using AIgnoredColorsArr.
  //ToDo: - Move the whole code to another (CPU) thread, to avoid blocking the UI.

  Result := False;

  if APlatformIndex < 0 then
  begin
    ADebuggingInfo := 'No platform selected.';
    Exit;
  end;

  if ADeviceIndex < 0 then
  begin
    ADebuggingInfo := 'No device selected.';
    Exit;
  end;

  BackgroundBmpWidth := ASourceBitmapWidth;
  BackgroundBmpHeight := ASourceBitmapHeight;
  SubBmpWidth := ASubBitmapWidth;
  SubBmpHeight := ASubBitmapHeight;

  KernelSrc := GetKernelSrcRGB(ABytesPerPixelOnSrc, ABytesPerPixelOnSub, SubBmpHeight);
  OpenCLDll := TOpenCL.Create;
  try
    if not OpenCLDll.Loaded then
      raise Exception.Create('OpenCL not available. The dll is expected to exist at ' + OpenCLDll.ExpectedDllLocation);

    Error := OpenCLDll.clGetPlatformIDs(0, nil, @PlatformCount);
    LogCallResult(Error, 'clGetPlatformIDs', 'PlatformCount: ' + IntToStr(PlatformCount));

    if APlatformIndex > PlatformCount - 1 then
    begin
      ADebuggingInfo := 'Selected platform is out of range.';
      Exit;
    end;

    GetMem(PlatformIDs, PlatformCount * SizeOf(cl_platform_id));
    try
      Error := OpenCLDll.clGetPlatformIDs(PlatformCount, PlatformIDs, nil);
      LogCallResult(Error, 'clGetPlatformIDs', '');

      DevType := CL_DEVICE_TYPE_GPU;

      Error := OpenCLDll.clGetDeviceIDs(PlatformIDs[APlatformIndex], DevType, 0, nil, @DeviceCount);
      LogCallResult(Error, 'clGetDeviceIDs', 'DeviceCount: ' + IntToStr(DeviceCount));

      if ADeviceIndex > DeviceCount - 1 then
      begin
        ADebuggingInfo := 'Selected device is out of range.';
        Exit;
      end;

      GetMem(DeviceIDs, DeviceCount * SizeOf(cl_device_id));
      try
        Error := OpenCLDll.clGetDeviceIDs(PlatformIDs[APlatformIndex], DevType, DeviceCount, DeviceIDs, nil);
        LogCallResult(Error, 'clGetDeviceIDs', '');

        Context := OpenCLDll.clCreateContext(nil, 1, @DeviceIDs[ADeviceIndex], nil, nil, Error);
        try
          if Context = nil then
            LogCallResult(Error, 'clCreateContext', '', 'Error is ' + IntToStr(Error));

          QueueProperties[0] := CL_QUEUE_PROPERTIES;
          QueueProperties[1] := CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE;
          QueueProperties[2] := 0;

          try
            CmdQueue := OpenCLDll.clCreateCommandQueueWithProperties(Context, DeviceIDs[ADeviceIndex], @QueueProperties, Error);
            if (CmdQueue = nil) or (Error <> 0) then
              LogCallResult(Error, 'clCreateCommandQueueWithProperties CmdQueue', '');
          except
            on E: Exception do
              LogCallResult(Error, 'clCreateCommandQueueWithProperties CmdQueue', '', 'Ex: ' + E.Message);
          end;

          QueueProperties[0] := CL_QUEUE_PROPERTIES;
          QueueProperties[1] := CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE or CL_QUEUE_ON_DEVICE or CL_QUEUE_ON_DEVICE_DEFAULT;
          QueueProperties[2] := 0;

          try
            SlaveCmdQueue := OpenCLDll.clCreateCommandQueueWithProperties(Context, DeviceIDs[ADeviceIndex], @QueueProperties, Error);  //also tested by creating this queue before the other one.  get_default_queue  still returns 0.
            if (SlaveCmdQueue = nil) or (Error <> 0) then
              LogCallResult(Error, 'clCreateCommandQueueWithProperties SlaveCmdQueue', '');
          except
            on E: Exception do
              LogCallResult(Error, 'clCreateCommandQueueWithProperties SlaveCmdQueue', '', 'Ex: ' + E.Message);
          end;

          try
            CLProgram := OpenCLDll.clCreateProgramWithSource(Context, 1, PPAnsiChar(@KernelSrc), nil, Error);
            try
              if CLProgram = nil then
                LogCallResult(Error, 'clCreateProgramWithSource', '');

              BuildOptions := '-g -cl-kernel-arg-info';  //used for getting additional debugging info from enqueue_kernel.
              //BuildOptions := nil;
              Error := OpenCLDll.clBuildProgram(CLProgram, 0, nil, BuildOptions, nil, nil);
              //LogCallResult(Error, 'clBuildProgram', 'Kernel code compiled.');  //commented, to allow the next call to clGetProgramBuildInfo

              if Error < CL_SUCCESS then
              begin
                SetLength(Info, 32768);
                SecondError := OpenCLDll.clGetProgramBuildInfo(CLProgram, DeviceIDs[ADeviceIndex], CL_PROGRAM_BUILD_LOG, Length(Info), @Info[1], InfoLen);
                SetLength(Info, InfoLen);
                LogCallResult(SecondError, 'clGetProgramBuildInfo', 'Additional build info.');

                Info := StringReplace(Info, #13#10, '|', [rfReplaceAll]);
                Info := StringReplace(Info, #10, '|', [rfReplaceAll]);
                LogCallResult(Error, 'clBuildProgram', 'Kernel code compiled.', Info);
              end;

              CLKernel := OpenCLDll.clCreateKernel(CLProgram, 'SlideSearch', Error);  //CLKernel := clCreateKernel(CLProgram, 'MatCmp', Error);
              try
                LogCallResult(Error, 'clCreateKernel', 'Kernel allocated.');

                Error := OpenCLDll.clGetKernelWorkGroupInfo(CLKernel, DeviceIDs[ADeviceIndex], CL_KERNEL_WORK_GROUP_SIZE, SizeOf(LocalSize), @LocalSize, InfoLen);
                LogCallResult(Error, 'clGetKernelWorkGroupInfo', 'Work group info obtained.');

                BackgroundBufferRef := OpenCLDll.clCreateBuffer(Context, CL_MEM_READ_ONLY, csize_t(ABytesPerPixelOnSrc * BackgroundBmpWidth * BackgroundBmpHeight), nil, Error);
                try
                  LogCallResult(Error, 'clCreateBuffer', 'Background buffer created.');

                  SubBufferRef := OpenCLDll.clCreateBuffer(Context, CL_MEM_READ_ONLY, csize_t(ABytesPerPixelOnSub * SubBmpWidth * SubBmpHeight), nil, Error);
                  try
                    LogCallResult(Error, 'clCreateBuffer', 'Sub buffer created.');

                    ResBufferRef := OpenCLDll.clCreateBuffer(Context, CL_MEM_WRITE_ONLY, csize_t(SizeOf(LongInt) * SubBmpHeight), nil, Error);
                    try
                      LogCallResult(Error, 'clCreateBuffer', 'Res buffer created.');

                      SetLength(DbgBuffer, 20);
                      DbgBufferRef := OpenCLDll.clCreateBuffer(Context, CL_MEM_WRITE_ONLY, csize_t(SizeOf(LongInt) * Length(DbgBuffer)), nil, Error); //10 items
                      try
                        LogCallResult(Error, 'clCreateBuffer', 'Dbg buffer created.');

                        Error := OpenCLDll.clEnqueueWriteBuffer(CmdQueue, BackgroundBufferRef, CL_TRUE, 0, csize_t(ABytesPerPixelOnSrc * BackgroundBmpWidth * BackgroundBmpHeight), ASrcBmpData, 0, nil, nil);
                        LogCallResult(Error, 'clEnqueueWriteBuffer', 'Background buffer written.');

                        Error := OpenCLDll.clEnqueueWriteBuffer(CmdQueue, SubBufferRef, CL_TRUE, 0, csize_t(ABytesPerPixelOnSub * SubBmpWidth * SubBmpHeight), ASubBmpData, 0, nil, nil);
                        LogCallResult(Error, 'clEnqueueWriteBuffer', 'Sub buffer written.');

                        XOffset := 0;
                        YOffset := 0;
                        ColorError := AColorErrorLevel;


                        Error := OpenCLDll.clSetKernelArg(CLKernel, 0, SizeOf(cl_mem), @BackgroundBufferRef); //sizeof(cl_mem)  is SizeOf(Pointer), which can be 4 or 8
                        LogCallResult(Error, 'clSetKernelArg', 'BackgroundBufferRef argument set.');

                        Error := OpenCLDll.clSetKernelArg(CLKernel, 1, SizeOf(cl_mem), @SubBufferRef); //sizeof(cl_mem)  is SizeOf(Pointer), which can be 4 or 8
                        LogCallResult(Error, 'clSetKernelArg', 'SubBufferRef argument set.');

                        Error := OpenCLDll.clSetKernelArg(CLKernel, 2, SizeOf(cl_mem), @ResBufferRef); //sizeof(cl_mem)  is SizeOf(Pointer), which can be 4 or 8
                        LogCallResult(Error, 'clSetKernelArg', 'ResBufferRef argument set.');

                        Error := OpenCLDll.clSetKernelArg(CLKernel, 3, SizeOf(cl_mem), @DbgBufferRef); //sizeof(cl_mem)  is SizeOf(Pointer), which can be 4 or 8
                        LogCallResult(Error, 'clSetKernelArg', 'DbgBufferRef argument set.');

                        Error := OpenCLDll.clSetKernelArg(CLKernel, 4, SizeOf(LongInt), @BackgroundBmpWidth);
                        LogCallResult(Error, 'clSetKernelArg', 'ABackgroundWidth argument set.');

                        Error := OpenCLDll.clSetKernelArg(CLKernel, 5, SizeOf(LongInt), @SubBmpWidth);
                        LogCallResult(Error, 'clSetKernelArg', 'ASubBmpWidth argument set.');

                        Error := OpenCLDll.clSetKernelArg(CLKernel, 6, SizeOf(LongInt), @SubBmpHeight);
                        LogCallResult(Error, 'clSetKernelArg', 'SubBmpHeight argument set.');

                        XOffset := BackgroundBmpWidth - SubBmpWidth - 1;
                        Error := OpenCLDll.clSetKernelArg(CLKernel, 7, SizeOf(LongInt), @XOffset);
                        LogCallResult(Error, 'clSetKernelArg', 'XOffset argument set.');

                        YOffset := BackgroundBmpHeight - SubBmpHeight - 1;
                        Error := OpenCLDll.clSetKernelArg(CLKernel, 8, SizeOf(LongInt), @YOffset);
                        LogCallResult(Error, 'clSetKernelArg', 'YOffset argument set.');

                        Error := OpenCLDll.clSetKernelArg(CLKernel, 9, SizeOf(Byte), @ColorError);
                        LogCallResult(Error, 'clSetKernelArg', 'ColorError argument set.');

                        Error := OpenCLDll.clSetKernelArg(CLKernel, 10, SizeOf(cl_ulong), SlaveCmdQueue);  //using SizeOf(cl_ulong), because the parameter is a QWord on kernel
                        LogCallResult(Error, 'clSetKernelArg', 'SlaveCmdQueue argument set.');

                        Error := OpenCLDll.clSetKernelArg(CLKernel, 11, SizeOf(ATotalErrorCount), @ATotalErrorCount);
                        LogCallResult(Error, 'clSetKernelArg', 'TotalErrorCount argument set.');

                        GlobalSize := SubBmpHeight;
                        LogCallResult(Error, 'Matrix comparison', 'Starting...');

                        GlobalSizeWithDeviceEnqueue := 1; //one master kernel, although not sure if Local should be 1
                        Error := OpenCLDll.clEnqueueNDRangeKernel(CmdQueue, CLKernel, 1, nil, @GlobalSizeWithDeviceEnqueue, nil, 0, nil, nil);
                        LogCallResult(Error, 'clEnqueueNDRangeKernel CmdQueue', '');

                        Error := OpenCLDll.clFinish(CmdQueue);     //see also ResBufferRef := OpenCLDll.clCreateBuffer  - the buffer is created to items longer
                        LogCallResult(Error, 'clFinish CmdQueue (Before clEnqueueReadBuffer)', '');
                        SetLength(DiffCntPerRow, GlobalSize);
                        Error := OpenCLDll.clEnqueueReadBuffer(CmdQueue, ResBufferRef, CL_TRUE, 0, csize_t(SizeOf(LongInt) * Length(DiffCntPerRow)), @DiffCntPerRow[0], 0, nil, nil);
                        LogCallResult(Error, 'clEnqueueReadBuffer DiffCntPerRow', '', '  kernel enqueue err is DiffCntPerRow[Len-2] = ' + IntToStr(DiffCntPerRow[Length(DiffCntPerRow) - 2]) + '  kernel get_default_queue is DiffCntPerRow[Len-1] = ' + IntToStr(DiffCntPerRow[Length(DiffCntPerRow) - 1]) + '  Length(DiffCntPerRow) = ' + IntToStr(Length(DiffCntPerRow)));

                        ADebuggingInfo := '  Res[0] = ' + IntToStr(DiffCntPerRow[0]) +
                                          '  Res[1] = ' + IntToStr(DiffCntPerRow[1]) +
                                          '  Res[2] = ' + IntToStr(DiffCntPerRow[2]) +
                                          '  Res[n - 4] = ' + IntToStr(DiffCntPerRow[Length(DiffCntPerRow) - 4]) +
                                          '  Res[n - 3] = ' + IntToStr(DiffCntPerRow[Length(DiffCntPerRow) - 3]) +
                                          '  Res[n - 2] = ' + IntToStr(DiffCntPerRow[Length(DiffCntPerRow) - 2]) +
                                          '  Res[n - 1] = ' + IntToStr(DiffCntPerRow[Length(DiffCntPerRow) - 1]);


                        FillChar(DbgBuffer[0], Length(DbgBuffer), SizeOf(DbgBuffer[0]));
                        Error := OpenCLDll.clEnqueueReadBuffer(CmdQueue, DbgBufferRef, CL_TRUE, 0, csize_t(SizeOf(LongInt) * Length(DbgBuffer)), @DbgBuffer[0], 0, nil, nil);
                        LogCallResult(Error, 'clEnqueueReadBuffer DbgBuffer', '', '  kernel enqueue err is ' + IntToStr(DbgBuffer[0]) + '  kernel enqueue_marker is ' + IntToStr(DiffCntPerRow[1]) + '  Length(DbgBuffer) = ' + IntToStr(Length(DbgBuffer)) + '  i = ' + IntToStr(i) + '  j = ' + IntToStr(j));

                        ADebuggingInfo := ADebuggingInfo + #13#10 +
                                          ',  enqueue_kernel = ' + IntToStr(DbgBuffer[0]) +
                                          ',  enqueue_marker = ' + IntToStr(DbgBuffer[1]) +
                                          ',  i = ' + IntToStr(DbgBuffer[2]) +
                                          ',  j = ' + IntToStr(DbgBuffer[3]) +
                                          ',  DifferentCount = ' + IntToStr(DbgBuffer[4]) +
                                          ',  Found = ' + IntToStr(DbgBuffer[5]) +
                                          ',  get_work_dim = ' + IntToStr(DbgBuffer[6]);

                        //Error := OpenCLDll.clFinish(SlaveCmdQueue);                     //CL_INVALID_COMMAND_QUEUE if command_queue is not a valid host command-queue.
                        //LogCallResult(Error, 'clFinish SlaveCmdQueue', '');
                      finally
                        OpenCLDll.clReleaseMemObject(DbgBufferRef);
                      end;
                    finally
                      OpenCLDll.clReleaseMemObject(ResBufferRef);
                    end;
                  finally
                    OpenCLDll.clReleaseMemObject(SubBufferRef);
                  end;
                finally
                  OpenCLDll.clReleaseMemObject(BackgroundBufferRef);
                end;
              finally  //clCreateKernel
                OpenCLDll.clReleaseKernel(CLKernel);
              end;
            finally
              OpenCLDll.clReleaseProgram(CLProgram);
            end;
          finally
            OpenCLDll.clReleaseCommandQueue(CmdQueue);
            OpenCLDll.clReleaseCommandQueue(SlaveCmdQueue);
          end;
        finally
          OpenCLDll.clReleaseContext(Context);
        end;
      finally
        Freemem(DeviceIDs, DeviceCount * SizeOf(cl_device_id));
      end;
    finally
      Freemem(PlatformIDs, PlatformCount * SizeOf(cl_platform_id));
    end;
  finally
    OpenCLDll.Free;
  end;
end;



function ExecutePlugin(APluginReference: Pointer;
                       AListOfPluginSettings: Pointer;
                       AListOfPluginSettingsLen: PDWord;

                       AOnActionPlugin_GetActionCount: TOnActionPlugin_GetActionCount;
                       AOnActionPlugin_GetActionInfoByIndex: TOnActionPlugin_GetActionInfoByIndex;
                       AOnActionPlugin_GetActionContentByIndex: TOnActionPlugin_GetActionContentByIndex;
                       AOnActionPlugin_ExecuteAction: TOnActionPlugin_ExecuteAction;
                       AOnActionPlugin_GetAllTemplateVars: TOnActionPlugin_GetAllTemplateVars;
                       AOnActionPlugin_SetTemplateVar: TOnActionPlugin_SetTemplateVar;
                       AOnActionPlugin_DebugPoint: TOnActionPlugin_DebugPoint;
                       AOnActionPlugin_AddToLog: TOnActionPlugin_AddToLog;
                       AOnActionPlugin_SetResultImg: TOnActionPlugin_SetResultImg;
                       AOnActionPlugin_LoadBitmap: TOnActionPlugin_LoadBitmap;
                       AOnActionPlugin_GetAllowedFilesInfo: TOnActionPlugin_GetAllowedFilesInfo;
                       AOnActionPlugin_SetBitmap: TOnActionPlugin_SetBitmap;
                       AOnActionPlugin_Screenshot: TOnActionPlugin_Screenshot;
                       AOnActionPlugin_CheckStopAllActionsOnDemand: TOnActionPlugin_CheckStopAllActionsOnDemand;
                       AOnActionPlugin_InMemFS: TOnActionPlugin_InMemFS;
                       AOnActionPlugin_AppProcMsg: TOnActionPlugin_AppProcMsg
                       ): Boolean; cdecl;
var
  ActionCount: Integer;
  PluginSettingsStr, AllVarsStr: string;
  ListOfAllVars: TStringList;
  PluginSettings: TStringList;

  procedure SetTemplateVar(AVarName, AVarValue: string);
  begin
    AOnActionPlugin_SetTemplateVar(APluginReference, @AVarName[1], @AVarValue[1]);
  end;

  procedure GetActionInfoByIndex(AIndex: Integer; out AActionName: string; var AActionType: DWord);
  var
    Buffer: string;
    ActionNamePtr: Pointer;
    NameLengthDWord: DWord;
  begin
    SetLength(Buffer, CMaxSharedStringLength + 1);
    ActionNamePtr := @Buffer[1];
    NameLengthDWord := 0;

    AActionName := '';
    AOnActionPlugin_GetActionInfoByIndex(APluginReference, AIndex, ActionNamePtr, @NameLengthDWord, @AActionType);
    SetPointedContentToString(ActionNamePtr, AActionName);
    SetLength(AActionName, NameLengthDWord);
  end;

  procedure GetAllTemplateVars(out AAllTemplateVars: string);  //AAllTemplateVars are encoded as CRLF separated key=value strings, ready to be used on a TStringlist
  var
    Buffer: string;
    AllTemplateVarsPtr: Pointer;
    NameLengthDWord: DWord;
  begin
    SetLength(Buffer, CMaxSharedStringLength + 1);
    AllTemplateVarsPtr := @Buffer[1];
    NameLengthDWord := 0;
    AAllTemplateVars := '';

    AOnActionPlugin_GetAllTemplateVars(APluginReference, AllTemplateVarsPtr, @NameLengthDWord);  //decode action execution results

    SetPointedContentToString(AllTemplateVarsPtr, AAllTemplateVars);
    SetLength(AAllTemplateVars, NameLengthDWord);
  end;

  function GetPluginSettings: string;
  begin
    SetLength(Result, CMaxSharedStringLength);
    SetPointedContentToString(AListOfPluginSettings, Result);
    SetLength(Result, AListOfPluginSettingsLen^);
  end;


  procedure ExecFindSubControlOnGPU(APlatformIndex, ADeviceIndex: Integer);
  var
    SourceBitmap, SubBitmap: TBitmap;
    ColorErrorLevel: Integer;
    SubCnvXOffset, SubCnvYOffset: Integer;
    AFoundBitmaps: TCompRecArr;
    TotalErrorCount, FastSearchColorErrorCount: Integer;
    AUseFastSearch, AIgnoreBackgroundColor, AGetAllBitmaps: Boolean;
    ABackgroundColor: TColor;
    AIgnoredColorsArr: TColorArr;
    ASleepySearch: Byte;
    AOutsideTickCount, APrecisionTimeout: QWord;
    AThreadCount: Integer;
    AResultedErrorCount: Integer;
    AStopSearchOnDemand: PBoolean;
    StopSearchOnMismatch: Boolean;

    SourceStream, SubStream: TMemoryStream;
    i: Integer;
    BytesPerPixelSrc, BytesPerPixelSub: Integer;
    ScLn: Pointer;
    MatchResult: Boolean;
    DebuggingInfo: string;
  begin
    AStopSearchOnDemand := nil;
    SetTemplateVar('$MatchResult$', 'not executed');

    SourceBitmap := TBitmap.Create;
    SubBitmap := TBitmap.Create;
    SourceStream := TMemoryStream.Create;
    SubStream := TMemoryStream.Create;
    try
      WipeBitmap(SourceBitmap, 300, 400);
      WipeBitmap(SubBitmap, 30, 40);

      SourceBitmap.Canvas.Font.Color := clBlack;
      SourceBitmap.Canvas.TextOut(21, 17, 'abc');
      SubBitmap.Canvas.Font.Color := clBlack;
      SubBitmap.Canvas.TextOut(0, 0, 'abc');
      StopSearchOnMismatch := True;
      ASleepySearch := 0;
      ColorErrorLevel := 10;
      TotalErrorCount := 10;
      FastSearchColorErrorCount := 5;
      SubCnvXOffset := -1;
      SubCnvYOffset := -1;
      AUseFastSearch := True;
      AIgnoreBackgroundColor := False;
      AGetAllBitmaps := False;
      ABackgroundColor := clWhite;   //not used    //clFuchsia
      SetLength(AIgnoredColorsArr, 0);

      if SourceBitmap.PixelFormat = pf24bit then
        BytesPerPixelSrc := 3
      else
        BytesPerPixelSrc := 4;

      if SubBitmap.PixelFormat = pf24bit then
        BytesPerPixelSub := 3
      else
        BytesPerPixelSub := 4;

      for i := 0 to SourceBitmap.Height - 1 do
      begin
        ScLn := SourceBitmap.{%H-}ScanLine[i];
        SourceStream.Write(ScLn^, SourceBitmap.Width * BytesPerPixelSrc);
      end;

      for i := 0 to SubBitmap.Height - 1 do
      begin
        ScLn := SubBitmap.{%H-}ScanLine[i];
        SubStream.Write(ScLn^, SubBitmap.Width * BytesPerPixelSub);
      end;

      AOutsideTickCount := GetTickCount64;
      APrecisionTimeout := 15000;
      MatchResult := BitmapPosMatch_BruteForceOnGPU(APlatformIndex,
                                                    ADeviceIndex,
                                                    SourceStream.Memory,
                                                    SubStream.Memory,
                                                    BytesPerPixelSrc,
                                                    BytesPerPixelSub,
                                                    SourceBitmap.Width,
                                                    SourceBitmap.Height,
                                                    SubBitmap.Width,
                                                    SubBitmap.Height,
                                                    ColorErrorLevel,
                                                    SubCnvXOffset,
                                                    SubCnvYOffset,
                                                    AFoundBitmaps,
                                                    TotalErrorCount,
                                                    FastSearchColorErrorCount,
                                                    AUseFastSearch,
                                                    AIgnoreBackgroundColor,
                                                    AGetAllBitmaps,
                                                    ABackgroundColor,
                                                    AIgnoredColorsArr,
                                                    ASleepySearch,
                                                    AOutsideTickCount,
                                                    APrecisionTimeout,
                                                    AThreadCount,
                                                    AResultedErrorCount,
                                                    DebuggingInfo,
                                                    AStopSearchOnDemand,
                                                    StopSearchOnMismatch);
    finally
      SourceStream.Free;
      SubStream.Free;
      SourceBitmap.Free;
      SubBitmap.Free;
    end;

    SetTemplateVar('$MatchResult$', BoolToStr(MatchResult, 'True', 'False'));
    SetTemplateVar('$MatchDuration$', IntToStr(GetTickCount64 - AOutsideTickCount));
    SetTemplateVar('$MatchSubCnvXOffset$', IntToStr(SubCnvXOffset));    //20 + 2
    SetTemplateVar('$MatchSubCnvYOffset$', IntToStr(SubCnvYOffset));    //16 + 3
    SetTemplateVar('$PluginDebuggingInfo$', DebuggingInfo);
  end; //ExecFindSubControlOnGPU

  procedure ExecFindSubControlOnPlugin(APlatformIndex, ADeviceIndex: Integer; var AFindSubControlOptions: TClkFindSubControlOptions; var AActionOptions: TClkActionOptions);
  begin
    //ToDo move FindSubControl stuff from ClickerActionExecution.pas into a new unit,
    //which can be included in this project, then call ExecuteFindSubControlAction

    //ToDo: replace the following code with ExecuteFindSubControlAction
    if AFindSubControlOptions.MatchBitmapAlgorithm = mbaBruteForceOnGPU then
      ExecFindSubControlOnGPU(APlatformIndex, ADeviceIndex)
    else
      AddToLog('FindSubControl not implemented yet.');
  end;

  procedure GetCLInfo;
  var
    OpenCLDll: TOpenCL;

    procedure LogCallResult(AError: Integer; AFuncName, AInfo: string);
    begin
      //call some event
      if AError <> 0 then
        raise Exception.Create('Error ' + CLErrorToStr(AError) + ' instead of "' + AInfo + '" at "' + AFuncName + '" OpenCL API call.');
    end;

    procedure GetPlatformInfo(APlatformIndex: Integer; APlatform: cl_platform_id; APlatformParamName: cl_platform_info; APlatformParamNameStr: string);
    var
      InfoLen: csize_t;
      Info: string;
      Error: Integer;
    begin
      SetLength(Info, 32768);
      Error := OpenCLDll.clGetPlatformInfo(APlatform, APlatformParamName, csize_t(Length(Info)), @Info[1], InfoLen);
      LogCallResult(Error, 'clGetPlatformInfo(' + APlatformParamNameStr + ')', '');
      SetLength(Info, InfoLen);
      SetTemplateVar('$CL_' + APlatformParamNameStr + '[' + IntToStr(APlatformIndex) + ']$', Info);
    end;

    procedure GetDeviceInfo(APlatformIndex, ADeviceIndex: Integer; ADevice: cl_Device_id; ADeviceParamName: cl_device_info; ADeviceParamNameStr: string; ACLParamIsInt: Boolean = False);
    var
      InfoLen: csize_t;
      Info: string;
      Error: Integer;
    begin
      SetLength(Info, 32768);
      Error := OpenCLDll.clGetDeviceInfo(ADevice, ADeviceParamName, csize_t(Length(Info)), @Info[1], InfoLen);
      LogCallResult(Error, 'clGetDeviceInfo(' + ADeviceParamNameStr + ')', '');
      SetLength(Info, InfoLen);

      if ACLParamIsInt then
        Info := IntToStr(PDWord(@Info[1])^);

      SetTemplateVar('$CL_' + ADeviceParamNameStr + '[' + IntToStr(APlatformIndex) + ', ' + IntToStr(ADeviceIndex) + ']$', Info);
    end;

  var
    Error: Integer;
    PlatformCount, DeviceCount: cl_uint;
    PlatformIDs: Pcl_platform_id;
    DeviceIDs: Pcl_device_id;
    i, j: Integer;
  begin
    OpenCLDll := TOpenCL.Create;
    try
      if not OpenCLDll.Loaded then
        raise Exception.Create('OpenCL not available. The dll is expected to exist at ' + OpenCLDll.ExpectedDllLocation);

      Error := OpenCLDll.clGetPlatformIDs(0, nil, @PlatformCount);
      LogCallResult(Error, 'clGetPlatformIDs', 'PlatformCount: ' + IntToStr(PlatformCount));
      SetTemplateVar('$CL_PlatformCount$', IntToStr(PlatformCount));

      GetMem(PlatformIDs, PlatformCount * SizeOf(cl_platform_id));
      try
        Error := OpenCLDll.clGetPlatformIDs(PlatformCount, PlatformIDs, nil);
        LogCallResult(Error, 'clGetPlatformIDs', '');

        for i := 0 to PlatformCount - 1 do
        begin
          GetPlatformInfo(i, PlatformIDs[i], CL_PLATFORM_PROFILE, 'PlatformProfile');
          GetPlatformInfo(i, PlatformIDs[i], CL_PLATFORM_VERSION, 'PlatformVersion');
          GetPlatformInfo(i, PlatformIDs[i], CL_PLATFORM_NAME, 'PlatformName');
          GetPlatformInfo(i, PlatformIDs[i], CL_PLATFORM_VENDOR, 'PlatformVendor');
          GetPlatformInfo(i, PlatformIDs[i], CL_PLATFORM_EXTENSIONS, 'PlatformExtensions');

          Error := OpenCLDll.clGetDeviceIDs(PlatformIDs[i], CL_DEVICE_TYPE_GPU, 0, nil, @DeviceCount);
          LogCallResult(Error, 'clGetDeviceIDs', 'DeviceCount: ' + IntToStr(DeviceCount));
          SetTemplateVar('$CL_DeviceCount$', IntToStr(DeviceCount));

          GetMem(DeviceIDs, DeviceCount * SizeOf(cl_device_id));
          try
            Error := OpenCLDll.clGetDeviceIDs(PlatformIDs[i], CL_DEVICE_TYPE_GPU, DeviceCount, DeviceIDs, nil);
            LogCallResult(Error, 'clGetDeviceIDs', '');

            for j := 0 to DeviceCount - 1 do
            begin
              GetDeviceInfo(i, j, DeviceIDs[j], CL_DEVICE_NAME, 'DeviceName');
              GetDeviceInfo(i, j, DeviceIDs[j], CL_DEVICE_VENDOR, 'DeviceVendor');
              GetDeviceInfo(i, j, DeviceIDs[j], CL_DEVICE_VERSION, 'DeviceVersion');
              GetDeviceInfo(i, j, DeviceIDs[j], CL_DEVICE_PROFILE, 'DeviceProfile');
              GetDeviceInfo(i, j, DeviceIDs[j], CL_DEVICE_OPENCL_C_VERSION, 'DeviceOpenCLCVersion');
              GetDeviceInfo(i, j, DeviceIDs[j], CL_DEVICE_EXTENSIONS, 'DeviceExtensions');

              GetDeviceInfo(i, j, DeviceIDs[j], CL_DEVICE_TYPE_INFO, 'DeviceTypeInfo', True);    //CL_DEVICE_TYPE_GPU
              GetDeviceInfo(i, j, DeviceIDs[j], CL_DEVICE_GLOBAL_MEM_SIZE, 'DeviceGlobalMemSize', True);
              GetDeviceInfo(i, j, DeviceIDs[j], CL_DEVICE_IMAGE_SUPPORT, 'DeviceImageSupport', True);
              GetDeviceInfo(i, j, DeviceIDs[j], CL_DEVICE_LOCAL_MEM_SIZE, 'DeviceLocalMemSize', True);
              GetDeviceInfo(i, j, DeviceIDs[j], CL_DEVICE_AVAILABLE, 'DeviceAvailable', True);
              GetDeviceInfo(i, j, DeviceIDs[j], CL_DEVICE_COMPILER_AVAILABLE, 'DeviceCompilerAvailable', True);
              GetDeviceInfo(i, j, DeviceIDs[j], CL_DEVICE_EXECUTION_CAPABILITIES, 'DeviceExecutionCapabilities', True);
            end;
          finally
            Freemem(DeviceIDs, DeviceCount * SizeOf(cl_device_id));
          end;
        end;
      finally
        Freemem(PlatformIDs, PlatformCount * SizeOf(cl_platform_id));
      end;
    finally
      OpenCLDll.Free;
    end;

    SetTemplateVar('$CL_RequiredExtensionsFor_queue_t$', '__opencl_c_device_enqueue, __opencl_c_generic_address_space, __opencl_c_program_scope_global_variables (OpenCLC2.0)');
    SetTemplateVar('$CL_RequiredExtensionsFor_image1d_t$', '__opencl_c_images (OpenCLC3.0)');
  end;

var
  FindSubControlActionPropertiesStr: string;
  ListOfFindSubControlActionProperties: TStringList;
  FindSubControlOptions: TClkFindSubControlOptions;
  FindSubControlActionOptions: TClkActionOptions;
  PlatformIndex, DeviceIndex: Integer;
begin
  Result := True;
  try
    DefaultOnActionPlugin_DebugPoint := AOnActionPlugin_DebugPoint;
    DefaultPluginReference := APluginReference;
    AddToLogCallback := AOnActionPlugin_AddToLog;

    ListOfAllVars := TStringList.Create;
    try
      PluginSettings := TStringList.Create;
      try
        if not DbgPoint('Entering ExecutePlugin', '') then     //see ClkDbgSym.ppr for expected statement formats
          Exit;

        ActionCount := AOnActionPlugin_GetActionCount(APluginReference);
        if ActionCount = 0 then
        begin
          SetTemplateVar(CActionPlugin_ExecutionResultErrorVar, 'This plugin does not run on an empty template.');
          Exit;
        end;

        PluginSettingsStr := GetPluginSettings;
        PluginSettings.Text := PluginSettingsStr;

        if not DbgPoint('Second debug point', '') then     //see ClkDbgSym.ppr for expected statement formats
          Exit;

        if PluginSettings.Count <> CPropertiesCount then
        begin
          SetTemplateVar(CActionPlugin_ExecutionResultErrorVar, 'Cannot get the list of plugin properties.');
          Exit;
        end;

        GetAllTemplateVars(AllVarsStr);
        ListOfAllVars.Text := AllVarsStr;

        if PluginSettings.Values[COperationModePropertyName] = COperationMode_GetCapabilities_Name then
        begin
          GetCLInfo;
          Exit;
        end;

        if PluginSettings.Values[COperationModePropertyName] = COperationMode_Execute_Name then
        begin
          GetAllTemplateVars(AllVarsStr);
          ListOfAllVars.Text := AllVarsStr;
          FindSubControlActionPropertiesStr := EvaluateAllReplacements(ListOfAllVars, PluginSettings.Values[CFindSubControlActionPropertiesVarPropertyName]);
          ListOfFindSubControlActionProperties := TStringList.Create;
          try
            ListOfFindSubControlActionProperties.Text := StringReplace(FindSubControlActionPropertiesStr, '&', #13#10, [rfReplaceAll]);
            SetFindSubControlActionProperties(ListOfFindSubControlActionProperties, nil, FindSubControlOptions, FindSubControlActionOptions);
          finally
            ListOfFindSubControlActionProperties.Free;
          end;

          PlatformIndex := StrToIntDef(PluginSettings.Values[CPlatformIndexPropertyName], -1);
          DeviceIndex := StrToIntDef(PluginSettings.Values[CDeviceIndexPropertyName], -1);

          ExecFindSubControlOnPlugin(PlatformIndex, DeviceIndex, FindSubControlOptions, FindSubControlActionOptions);
        end;

      finally
        PluginSettings.Free;
      end;
    finally
      ListOfAllVars.Free;
    end;
  except
    on E: Exception do
    begin
      Result := False;
      SetTemplateVar(CActionPlugin_ExecutionResultErrorVar, 'Plugin ex: ' + E.Message);
    end;
  end;
end;


exports
  GetAPIVersion,
  GetListOfProperties,
  ExecutePlugin;

begin
end.

